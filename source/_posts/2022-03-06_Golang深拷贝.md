---
title: Golang深拷贝
date: 2022-03-06 14:55:33
tags: 
  - Golang
categories: 
  - - 学习日志
    - Golang
---

# Go里的copy
在Go程序里，从变量赋值，到函数传参，对象的复制随处可见，用过其他语言的话，可能会由于惯性思维踩到Go对象复制的坑，例如：
- ## 变量赋值
在Java里类型分为基本类型和引用类型，对于基础类型的变量在赋值给另一变量时，实际是对该变量做了一次copy，<!-- more --> 这点在Golang中也不例外。然而对于非基础类型的变量，在赋值给另一变量时，在Java中实际上是copy了对象的引用，对新的变量的任何修改都会反映到原变量上，例如：
  ``` java
    public class Test {
        private static class Person {
            public String name;
            public int age;

            public Person(String name, int age) {
                this.name = name;
                this.age = age;
            }
        }

        public static void main(String[] args) {
            Person a = new Person("one", 1);
            Person b = a;
            b.age = 10;
            System.out.println("person a's age is: " + a.age);
        }
    }
  ```

      ❯ java ./Test.java
      person a's age is: 10

  但是在Go里，当把一个复杂对象变量赋值给另一个变量时，实际上是做了一次浅拷贝，所以当修改新变量的非指针和引用类型字段时，原变量是不会被影响的，例如：
  ``` golang
    package main

    import (
            "fmt"
    )

    type House struct {
            Address string
    }

    type Person struct {
            Name string
            Age int
            House House
    }


    func main() {
            a := Person{Name: "one", Age: 1, House: House{Address: "here"}}
            b := a
            b.Age = 10
            fmt.Printf("person a's age is %d\n", a.Age)

            b.House.Address = "there"
            fmt.Printf("person a's address is '%s'", a.House.Address)
    }
  ```

      ❯ go run .\main.go
      person a's age is 1
      person a's address is 'here'

  注意到修改变量b的House字段并没有影响变量a的House，这是因为House字段是值类型。在Go里除了指针、slice、map, channel、interface之外的类型其实都是值类型，所以House字段和其他所有基础类型一样，拷贝时是将整个对象进行拷贝(即值拷贝)，而不像Java那样仅仅拷贝对象的引用。
- ## 函数传参
在Go中函数传参实际都会发生变量的复制，即使是引用类型也不例外，并没有传引用的概念，这点要和Java区分开。所以在Go函数里修改非引用类型参数并不会改变原始参数的值，但是对于引用类型，实际是隐式传入了变量的指针，所以对于这类参数的的修改，就像Java那样会改变原始参数的值。Go函数参数传值的规范更准确的说是只针对数据结构中固定的部分传值，例如传递slice时，仅仅是对slice结构体做了浅拷贝，其间接指向的内存并不会被复制，因此如果通过一些hack的方式修改传入函数的slice结构的len字段时，并不会改变原始实参slice的len, 这一点得特别注意，如果将slice传入函数，在函数里对其扩容，原slice并不会改变，这也是为什么append函数会返回一个新的slice。
  ``` golang
    package main

    import (
        "fmt"
        "unsafe"
    )

    type slice struct {
        array unsafe.Pointer
        len   int
        cap   int
    }

    func changeSliceLength(buf []int) {
        fmt.Printf("length of buf: %d\n", len(buf))
        ptr := (*slice)(unsafe.Pointer(&buf))
        ptr.len = 100
        fmt.Printf("length of buf: %d\n", len(buf))
        buf[0] = 1
    }

    func main() {
        a := make([]int, 5, 10)
        fmt.Printf("a[0]: %d, length of a: %d\n", a[0], len(a))
        changeSliceLength(a)
        fmt.Printf("a[0]: %d, length of a: %d\n", a[0], len(a))
    }
  ```
      ❯ go run .\main.go
      a[0]: 0, length of a: 5
      length of buf: 5  
      length of buf: 100
      a[0]: 1, length of a: 5

# Go里如何deepcopy
在写Go程序时，难免面遇到需要深拷贝的场景，对于没有指针或者引用类型的结构，我们仅仅需要将该对象赋值给另一个变量就能轻易试下，但实际项目中, 复杂结构免不了有指针类型或者引用类型字段，而Go里又没有像Java里的Cloneable，这个时候如何实现深拷贝？

- ## 基于序列化/反序列化实现深拷贝
简单地说，我们可以先把对象序列化为字符串，然后再从字符串反序列化为对象，这就完成了一次深拷贝。序列化/反序列化可以选择json、thrift、protobuf等库，这里以json为例：
  ```golang
    package main

    import (
        "fmt"
        "encoding/json"
    )

    type House struct {
        Address string `json:"address"`
    }

    type Person struct {
        Name string `json:"name"`
        House *House `json:"house"`
    }

    func main() {
        a := &Person{Name: "one", House: &House{Address: "one's house"}}
        as, _ := json.Marshal(a)
        var b Person
        json.Unmarshal(as, &b)
        b.House.Address = "two's house"
        fmt.Printf("a's address: %s, b's address: %s\n", a.House.Address, b.House.Address)
    }
  ```

      ❯ go run .\main.go
      a's address: one's house, b's address: two's house
  
  采用这种方式进行深拷贝需要注意，由于会先序列化为字符串，因此会额外占用内存，当对象比较大时，需要格外留意内存占用情况，即使是thrift和protobuf这样的压缩比很高的库，也是存在风险的。另外在整个序列化和反序列化过程中，有可能由于频繁创建对象、申请内存，导致cpu占用也跟着升高！！！

- ## 使用reflect进行深拷贝
事实上，json和protobuf在序列化和反序列化时，使用了reflect库获取对象的字段和类型，那么我们也可以直接使用reflect来递归的读取对象的字段，并进行copy，这样就减少了序列化带来的内存占用，以及频繁字节数组扩容带来的cpu占用上升问题，并且可以完全去除反序列化的过程。不过这种方式的问题是，Go的reflect.Value对象不能复用，即使是相同类型的两个不同变量，也需要重新创建reflect.Value对象，这也造成reflect性能很差。
```golang
package main

import (
	"fmt"
	"reflect"
)

type House struct {
	Address string `json:"address"`
}

type Person struct {
	Name  string `json:"name"`
	House *House `json:"house"`
}

func shallowCopyValue(v reflect.Value) reflect.Value {
	switch v.Type().Kind() {
	case reflect.Ptr:
		return shallowCopyValue(v.Elem()).Addr()
	case reflect.Interface:
		return shallowCopyValue(v.Elem())
	case reflect.Array, reflect.Map, reflect.Func, reflect.Chan:
		return v
	default:
		return reflect.New(v.Type()).Elem()
	}
}

func deepcopyValue(v reflect.Value) reflect.Value {
	var value reflect.Value
	if v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface {
		value = v.Elem()
	} else {
		value = v
	}
	newIns := shallowCopyValue(v)
	newValue := newIns
	if v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface {
		newValue = newIns.Elem()
	}

	for i := 0; value.Kind() == reflect.Struct && i < value.Type().NumField(); i++ {
		field := value.Field(i)
		if !field.IsValid() {
			continue
		}
		newValue.Field(i).Set(deepcopyValue(field))
	}
	return newIns
}

func Deepcopy(ins interface{}) interface{} {
	if nil == ins {
		return nil
	}
	return deepcopyValue(reflect.ValueOf(ins)).Interface()
}

func main() {
	a := &Person{Name: "one", House: &House{Address: "one's house"}}
	b := Deepcopy(a).(*Person)
	b.House.Address = "two's house"
	fmt.Printf("a's address: %s, b's address: %s\n", a.House.Address, b.House.Address)
}
```

      ❯ go run main.go
      a's address: one's house, b's address: two's house

- ## 在编译期根据对象结构生成相应的复制代码
一般的，我们深拷贝一个简单对象，可以直接new一个新对象，然后对每个字段单独赋值来达到深拷贝的目的，这种方式相比前两种方式资源占用会更少，但是这种方式对于字段很多、层次很复杂的结构来说，要写的语句很多，而且实际开发中，任何结构都会不断变化，这种方式不能应对时刻变化的需求，如果能做到根据结构的定义，动态生成每个字段的复制代码，那不就是理想的深拷贝方法吗。幸运的是Go的标准库提供了对go文件语法解析的库```go/ast```，借助这个库我们可以在编译期递归解析代码里的结构体，生成每个字段的复制语句.
### go/ast包生成抽象语法树
先来看一个读取并解析文件的例子
``` golang
// main.go
package main

import (
  "go/token"
  "go/parser"
  "go/ast"
  "log"
)

func main() {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "person.go", nil, parser.SpuriousErrors)
	if nil != err {
		log.Fatal(err)
	}
	ast.Print(fset, f)
}
```
我们在这里引入的```go/token```包定义了Go语言的词法标记和其对应的基础操作，而```go/parser```包是Go源码的解析器。这里我们使用ParseFile方法解析person.go文件，其返回一个AST对象。随后我们使用ast包提供的Print方法打印整个抽象语法数。
``` golang
// person.go
package main

type Home struct {
	Address string
}

type Person struct {
	Name string
	Age int
	Home *Home
}
```
      ❯ go run ./main.go
        0  *ast.File {
        1  .  Package: person.go:1:1
        2  .  Name: *ast.Ident {
        3  .  .  NamePos: person.go:1:9
        4  .  .  Name: "main"
        5  .  }
        6  .  Decls: []ast.Decl (len = 2) {
        7  .  .  0: *ast.GenDecl {
        8  .  .  .  TokPos: person.go:3:1
        9  .  .  .  Tok: type
      10  .  .  .  Lparen: -
      11  .  .  .  Specs: []ast.Spec (len = 1) {
      12  .  .  .  .  0: *ast.TypeSpec {
      13  .  .  .  .  .  Name: *ast.Ident {
      14  .  .  .  .  .  .  NamePos: person.go:3:6
      15  .  .  .  .  .  .  Name: "Home"
      16  .  .  .  .  .  .  Obj: *ast.Object {
      17  .  .  .  .  .  .  .  Kind: type
      18  .  .  .  .  .  .  .  Name: "Home"
      19  .  .  .  .  .  .  .  Decl: *(obj @ 12)
      20  .  .  .  .  .  .  }
      21  .  .  .  .  .  }
      22  .  .  .  .  .  Assign: -
      23  .  .  .  .  .  Type: *ast.StructType {
      24  .  .  .  .  .  .  Struct: person.go:3:11
      25  .  .  .  .  .  .  Fields: *ast.FieldList {
      26  .  .  .  .  .  .  .  Opening: person.go:3:18
      27  .  .  .  .  .  .  .  List: []*ast.Field (len = 1) {
      28  .  .  .  .  .  .  .  .  0: *ast.Field {
      29  .  .  .  .  .  .  .  .  .  Names: []*ast.Ident (len = 1) {
      30  .  .  .  .  .  .  .  .  .  .  0: *ast.Ident {
      31  .  .  .  .  .  .  .  .  .  .  .  NamePos: person.go:4:2
      32  .  .  .  .  .  .  .  .  .  .  .  Name: "Address"
      33  .  .  .  .  .  .  .  .  .  .  .  Obj: *ast.Object {
      34  .  .  .  .  .  .  .  .  .  .  .  .  Kind: var
      35  .  .  .  .  .  .  .  .  .  .  .  .  Name: "Address"
      36  .  .  .  .  .  .  .  .  .  .  .  .  Decl: *(obj @ 28)
      37  .  .  .  .  .  .  .  .  .  .  .  }
      38  .  .  .  .  .  .  .  .  .  .  }
      39  .  .  .  .  .  .  .  .  .  }
      40  .  .  .  .  .  .  .  .  .  Type: *ast.Ident {
      41  .  .  .  .  .  .  .  .  .  .  NamePos: person.go:4:10
      42  .  .  .  .  .  .  .  .  .  .  Name: "string"
      43  .  .  .  .  .  .  .  .  .  }
      44  .  .  .  .  .  .  .  .  }
      45  .  .  .  .  .  .  .  }
      46  .  .  .  .  .  .  .  Closing: person.go:5:1
      47  .  .  .  .  .  .  }
      48  .  .  .  .  .  .  Incomplete: false
      49  .  .  .  .  .  }
      50  .  .  .  .  }
      51  .  .  .  }
      52  .  .  .  Rparen: -
      53  .  .  }
      54  .  .  1: *ast.GenDecl {
      55  .  .  .  TokPos: person.go:7:1
      56  .  .  .  Tok: type
      57  .  .  .  Lparen: -
      58  .  .  .  Specs: []ast.Spec (len = 1) {
      59  .  .  .  .  0: *ast.TypeSpec {
      60  .  .  .  .  .  Name: *ast.Ident {
      61  .  .  .  .  .  .  NamePos: person.go:7:6
      62  .  .  .  .  .  .  Name: "Person"
      63  .  .  .  .  .  .  Obj: *ast.Object {
      64  .  .  .  .  .  .  .  Kind: type
      65  .  .  .  .  .  .  .  Name: "Person"
      66  .  .  .  .  .  .  .  Decl: *(obj @ 59)
      67  .  .  .  .  .  .  }
      68  .  .  .  .  .  }
      69  .  .  .  .  .  Assign: -
      70  .  .  .  .  .  Type: *ast.StructType {
      71  .  .  .  .  .  .  Struct: person.go:7:13
      72  .  .  .  .  .  .  Fields: *ast.FieldList {
      73  .  .  .  .  .  .  .  Opening: person.go:7:20
      74  .  .  .  .  .  .  .  List: []*ast.Field (len = 3) {
      75  .  .  .  .  .  .  .  .  0: *ast.Field {
      76  .  .  .  .  .  .  .  .  .  Names: []*ast.Ident (len = 1) {
      77  .  .  .  .  .  .  .  .  .  .  0: *ast.Ident {
      78  .  .  .  .  .  .  .  .  .  .  .  NamePos: person.go:8:2
      79  .  .  .  .  .  .  .  .  .  .  .  Name: "Name"
      80  .  .  .  .  .  .  .  .  .  .  .  Obj: *ast.Object {
      81  .  .  .  .  .  .  .  .  .  .  .  .  Kind: var
      82  .  .  .  .  .  .  .  .  .  .  .  .  Name: "Name"
      83  .  .  .  .  .  .  .  .  .  .  .  .  Decl: *(obj @ 75)
      84  .  .  .  .  .  .  .  .  .  .  .  }
      85  .  .  .  .  .  .  .  .  .  .  }
      86  .  .  .  .  .  .  .  .  .  }
      87  .  .  .  .  .  .  .  .  .  Type: *ast.Ident {
      88  .  .  .  .  .  .  .  .  .  .  NamePos: person.go:8:7
      89  .  .  .  .  .  .  .  .  .  .  Name: "string"
      90  .  .  .  .  .  .  .  .  .  }
      91  .  .  .  .  .  .  .  .  }
      92  .  .  .  .  .  .  .  .  1: *ast.Field {
      93  .  .  .  .  .  .  .  .  .  Names: []*ast.Ident (len = 1) {
      94  .  .  .  .  .  .  .  .  .  .  0: *ast.Ident {
      95  .  .  .  .  .  .  .  .  .  .  .  NamePos: person.go:9:2
      96  .  .  .  .  .  .  .  .  .  .  .  Name: "Age"
      97  .  .  .  .  .  .  .  .  .  .  .  Obj: *ast.Object {
      98  .  .  .  .  .  .  .  .  .  .  .  .  Kind: var
      99  .  .  .  .  .  .  .  .  .  .  .  .  Name: "Age"
      100  .  .  .  .  .  .  .  .  .  .  .  .  Decl: *(obj @ 92)
      101  .  .  .  .  .  .  .  .  .  .  .  }
      102  .  .  .  .  .  .  .  .  .  .  }
      103  .  .  .  .  .  .  .  .  .  }
      104  .  .  .  .  .  .  .  .  .  Type: *ast.Ident {
      105  .  .  .  .  .  .  .  .  .  .  NamePos: person.go:9:7
      106  .  .  .  .  .  .  .  .  .  .  Name: "int"
      107  .  .  .  .  .  .  .  .  .  }
      108  .  .  .  .  .  .  .  .  }
      109  .  .  .  .  .  .  .  .  2: *ast.Field {
      110  .  .  .  .  .  .  .  .  .  Names: []*ast.Ident (len = 1) {
      111  .  .  .  .  .  .  .  .  .  .  0: *ast.Ident {
      112  .  .  .  .  .  .  .  .  .  .  .  NamePos: person.go:10:2
      113  .  .  .  .  .  .  .  .  .  .  .  Name: "Home"
      114  .  .  .  .  .  .  .  .  .  .  .  Obj: *ast.Object {
      115  .  .  .  .  .  .  .  .  .  .  .  .  Kind: var
      116  .  .  .  .  .  .  .  .  .  .  .  .  Name: "Home"
      117  .  .  .  .  .  .  .  .  .  .  .  .  Decl: *(obj @ 109)
      118  .  .  .  .  .  .  .  .  .  .  .  }
      119  .  .  .  .  .  .  .  .  .  .  }
      120  .  .  .  .  .  .  .  .  .  }
      121  .  .  .  .  .  .  .  .  .  Type: *ast.StarExpr {
      122  .  .  .  .  .  .  .  .  .  .  Star: person.go:10:7
      123  .  .  .  .  .  .  .  .  .  .  X: *ast.Ident {
      124  .  .  .  .  .  .  .  .  .  .  .  NamePos: person.go:10:8
      125  .  .  .  .  .  .  .  .  .  .  .  Name: "Home"
      126  .  .  .  .  .  .  .  .  .  .  .  Obj: *(obj @ 16)
      127  .  .  .  .  .  .  .  .  .  .  }
      128  .  .  .  .  .  .  .  .  .  }
      129  .  .  .  .  .  .  .  .  }
      130  .  .  .  .  .  .  .  }
      131  .  .  .  .  .  .  .  Closing: person.go:11:1
      132  .  .  .  .  .  .  }
      133  .  .  .  .  .  .  Incomplete: false
      134  .  .  .  .  .  }
      135  .  .  .  .  }
      136  .  .  .  }
      137  .  .  .  Rparen: -
      138  .  .  }
      139  .  }
      140  .  Scope: *ast.Scope {
      141  .  .  Objects: map[string]*ast.Object (len = 2) {
      142  .  .  .  "Person": *(obj @ 63)
      143  .  .  .  "Home": *(obj @ 16)
      144  .  .  }
      145  .  }
      146  .  Unresolved: []*ast.Ident (len = 3) {
      147  .  .  0: *(obj @ 40)
      148  .  .  1: *(obj @ 87)
      149  .  .  2: *(obj @ 104)
      150  .  }
      151  }
通过与person.go源码比对，Package字段即源文件中的package关键字，Name字段即包名，而Decls字段则存放了源码中所有的结构体定义。Decls是一个ast.Decl类型的数组，go AST中所有声明节点都实现了Decl接口，因此我们在解析源码中所有结构体或类型定义时，只需要遍历Decls字段即可。
注意到Decl结构的Specs字段正是类型定义，他有两个关键字段：Name表示类型的名称，Type表示实际类型，在这里，Type是*ast.StructType类型, 这与我们声明中的struct对应，事实上Type字段也可能是其他类型，如：
  - FuncType       表示函数类型
  - InterfaceType  表示接口类型
  - ArrayType      表示数组或Slice
  - MapType        表示map
  - ChanType       表示Channel
  - Ident          表示标识符，可以表示变量名，或者基础类型如int，string
  - ParenExpr      表示括号包裹的表达式
  - SelectorExpr   表示字段选择器，如 a.field
  - StarExpr       表示指针

  其中StructType的Fields字段即结构体的字段列表，他是Field类型的数组。Field包括两个关键字段，```Names``` []*Ident类型，表示字段名, ```Type``` Expr类型，表示字段类型。
  从上面的例子，我们对go AST结构有了一个大概印象，同时可以总结出通过AST获得结构体字段列表的方法，接下来我们以Person结构举例，实际生成他的深拷贝方法看看。
  ### 深拷贝代码生成
  拷贝一个对象，重点是拷贝对象的每一个字段，通过遍历AST树，我们可以获得Struct的字段列表，进一步生成每一个字段的复制代码。go/ast包提供了```func Walk(v Visitor, node Node)```方法遍历AST树。Walk方法需要两个参数，第一个参数需要实现Visitor接口，第二个参数即AST的节点。Walk方法深度优先的调用v.Visit(node)，如果v.Visit(node)返回了一个非nil的Visitor对象w，则Walk会对node的所有子节点调用w.Visit方法。
  遍历AST的第一步，我们需要找到所有的Struct节点，而所有的结构体定义都在Decls列表里，所以首先我们需要实现:
    - FileVisitor   从AST根节点ast.File对象读取Decls字段，返回DeclVisitor
    - DeclVisitor   针对Decls列表的每一个元素返回TypeVisitor
    - TypeVisitor   识别type关键字声明的类型节点

  ```golang
	type FileVisitor int
	func (v FileVisitor) Visit(node ast.Node) ast.Visitor {
		if _, ok := node.(*ast.File); ok {
			return DeclVisitor(0)
		}
		return nil
	}

	type DeclVisitor int
	func (v DeclVisitor) Visit(node ast.Node) ast.Visitor {
		// GenDecl.Tok字段表示声明的类型，type字段定义的类型都是token.TYPE
		if decl, ok := node.(*ast.GenDecl); ok && decl.Tok == token.TYPE {
			return TypeVisitor(0)
		}
		return nil
	}

	type TypeVisitor int
	func (v TypeVisitor) Visit(node ast.Node) ast.Visitor {
		if spec, ok := node.(*ast.TypeSpec); ok {
			switch spec.Type.(type) {
			case *ast.StructType:
				generateStructCloneMethod(spec)
			}
		}
		return nil
	}
  ```
  在TypeVisitor中，我们通过判断节点的Type字段类型是否为*ast.StructType来识别结构体定义节点。我们利用generateStructCloneMethod来给一个结构体生成Clone方法做深拷贝。我们的目标Clone方法应当具有如下基本结构：
  ```golang
	func (t *<StructName>) Clone() *<StructName> {
		ins := new <StructName>()
		ins.<Field> = t.<Field>
		ins.<StructField> = t.<StructField>.Clone()
		...
		return ins
	}
  ```
	可以看出，我们只要获取到结构体名称，和字段名列表，就可以根据以上模板生成Clone方法。
	```golang
	const template = `
	func (t *<StructName>) Clone() *<StructName> {
		ins := new(<StructName>)
	<Fields>
		return ins
	}`

	func generateStructCloneMethod(spec *ast.TypeSpec) string {
		method := strings.ReplaceAll(template, "<StructName>", spec.Name.Name)
		var fields bytes.Buffer
		for _, field := range (spec.Type.(*ast.StructType)).Fields.List {
			switch st := field.Type.(type) {
			case *ast.Ident:
				fields.WriteString(cloneIdentField(field.Names[0].Name, st))
			case *ast.StarExpr:
				switch id := st.X.(type) {
				case *ast.Ident:
					fields.WriteString(cloneIdentField(field.Names[0].Name, id))
				}
			}
		}
		return strings.ReplaceAll(method, "<Fields>", fields.String())
	}

	func cloneIdentField(fieldName string, st *ast.Ident) string {
		var fieldTmp string
		if isBaseType(st.Name) {
			fieldTmp = "\tins.<FieldName> = t.<FieldName>\n"
		} else {
			fieldTmp = "\tins.<FieldName> = t.<FieldName>.Clone()\n"
		}
		return strings.ReplaceAll(fieldTmp, "<FieldName>", fieldName)
	}

	func isBaseType(tp string) bool {
		switch tp {
		case "string", "int", "int8", "int16", "int32", "int64", 
			"uint", "uint8", "uint16", "uint32", "uint64", 
			"float32", "float64", "bool", "rune", "byte":
			return true
		}
		return false
	}
	```
	这里我们在处理非基础类型时假定该字段实现了Clone方法，这样不用去读取该字段原始定义。运行程序后，输出如下：

		func (t *Home) Clone() *Home {
			ins := new(Home)
			ins.Address = t.Address

			return ins
		}

		func (t *Person) Clone() *Person {
			ins := new(Person)
			ins.Name = t.Name
			ins.Age = t.Age
			ins.Home = t.Home.Clone()

			return ins
		}

	我们之后只需要将程序输出追加到person.go文件即可。来看实际使用生成的Clone方法进行深拷贝的效果：
	```golang
	func main() {
		personA := &Person{
			Name: "A",
			Age:  10,
			Home: &Home{
				Address: "A's home",
			},
		}
		personB := personA.Clone()
		personB.Home.Address = "B's home"
		fmt.Printf("person a: %+v, home: %+v\n", personA, personA.Home)
		fmt.Printf("person b: %+v, home: %+v\n", personB, personB.Home)
	}
	```
	  
		❯ go run person.go
		person a: &{Name:A Age:10 Home:0xc000038240}, home: &{Address:A's home}
		person b: &{Name:A Age:10 Home:0xc000038250}, home: &{Address:B's home}

	这里Person和Home结构都比较简单，所以只考虑了基础类型和指针类型的拷贝，感兴趣的读者可以试着自己实现其他类型的拷贝，这里就不赘述了。
	以下为对以上的Person对象分别使用json序列化和Clone方法实现深拷贝的benchmark数据，可以看到Clone方法速度是json序列化的60倍，而内存占用则只有1/23，当要复制的对象更复杂时，差距还会更大

		goos: windows
		goarch: amd64
		pkg: clone_gen
		cpu: Intel(R) Core(TM) i5-4590T CPU @ 2.00GHz
		BenchmarkSerializer-4             479168              2468 ns/op             376 B/op         10 allocs/op
		BenchmarkClone-4                25548656                40.68 ns/op           16 B/op          1 allocs/op
		PASS
		ok      clone_gen       3.361s