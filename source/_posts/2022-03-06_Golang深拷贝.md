---
title: Golang深拷贝
date: 2022-03-06 14:55:33
tags:
  - Golang
categories:
  - - 学习日志
    - Golang
---

# Go里的copy
在Go程序里，从变量赋值，到函数传参，对象的复制随处可见，用过其他语言的话，可能会由于惯性思维踩到Go对象复制的坑，例如：
- ## 变量赋值
在Java里类型分为基本类型和引用类型，对于基础类型的变量在赋值给另一变量时，实际是对该变量做了一次copy，这点在Golang中也不例外。然而对于非基础类型的变量，在赋值给另一变量时，在Java中实际上是copy了对象的引用，对新的变量的任何修改都会反映到原变量上，例如：
  ``` java
    public class Test {
        private static class Person {
            public String name;
            public int age;

            public Person(String name, int age) {
                this.name = name;
                this.age = age;
            }
        }

        public static void main(String[] args) {
            Person a = new Person("one", 1);
            Person b = a;
            b.age = 10;
            System.out.println("person a's age is: " + a.age);
        }
    }
  ```

      ❯ java ./Test.java
      person a's age is: 10

  但是在Go里，当把一个复杂对象变量赋值给另一个变量时，实际上是做了一次浅拷贝，所以当修改新变量的非指针和引用类型字段时，原变量是不会被影响的，例如：
  ``` golang
    package main

    import (
            "fmt"
    )

    type House struct {
            Address string
    }

    type Person struct {
            Name string
            Age int
            House House
    }


    func main() {
            a := Person{Name: "one", Age: 1, House: House{Address: "here"}}
            b := a
            b.Age = 10
            fmt.Printf("person a's age is %d\n", a.Age)

            b.House.Address = "there"
            fmt.Printf("person a's address is '%s'", a.House.Address)
    }
  ```

      ❯ go run .\main.go
      person a's age is 1
      person a's address is 'here'

  注意到修改变量```b```的House字段并没有影响变量```a```的House，这是因为```House```字段是值类型。在Go里除了指针、slice、map, channel之外的类型其实都是值类型，所以House字段的和其他所有基础类型一样，拷贝时是将整个对象进行拷贝，而不像Java那样仅仅拷贝对象的引用。
- ## 函数传参
在Go中函数传参实际都会发生变量的复制，即使是引用类型也不例外，并没有传引用的概念，这点要和Java区分开。所以在Go函数里修改非引用类型参数并不会改变原始参数的值，但是对于引用类型，实际是隐式传入了变量的指针，所以对于这类参数的的修改，就像Java那样会改变原始参数的值。Go函数参数传值的规范更准确的说是只针对数据结构中固定的部分传值，例如传递slice时，仅仅是对slice结构体做了浅拷贝，其间接指向的内存并不会被复制，因此如果想通过一些hack的方式修改传入函数的slice结构的len字段时，并不会改变原始实参slice的len
  ``` golang
    package main

    import (
        "fmt"
        "unsafe"
    )

    type slice struct {
        array unsafe.Pointer
        len   int
        cap   int
    }

    func changeSliceLength(buf []int) {
        fmt.Printf("length of buf: %d\n", len(buf))
        ptr := (*slice)(unsafe.Pointer(&buf))
        ptr.len = 100
        fmt.Printf("length of buf: %d\n", len(buf))
        buf[0] = 1
    }

    func main() {
        a := make([]int, 5, 10)
        fmt.Printf("a[0]: %d, length of a: %d\n", a[0], len(a))
        changeSliceLength(a)
        fmt.Printf("a[0]: %d, length of a: %d\n", a[0], len(a))
    }
  ```
      ❯ go run .\main.go
      a[0]: 0, length of a: 5
      length of buf: 5  
      length of buf: 100
      a[0]: 1, length of a: 5

# Go里如何deepcopy
在写Go程序时，难免面遇到需要深拷贝的场景，对于没有指针或者引用类型的结构，我们仅仅需要将该对象赋值给另一个变量就能轻易试下，但实际项目中, 复杂结构免不了有指针类型或者引用类型字段，而Go里又没有像Java里的Cloneable，这个时候如何实现深拷贝？

- ## 基于序列化/反序列化实现深拷贝
简单地说，我们可以先把对象序列化为字符串，然后再从字符串反序列化为对象，这就完成了一次深拷贝。序列化/反序列化可以选择json、thrift、protobuf等库，这里以json为例：
```golang
package main

import (
    "fmt"
    "encoding/json"
)

type House struct {
    Address string `json:"address"`
}

type Person struct {
    Name string `json:"name"`
    House *House `json:"house"`
}

func main() {
    a := &Person{Name: "one", House: &House{Address: "one's house"}}
    as, _ := json.Marshal(a)
    var b Person
    json.Unmarshal(as, &b)
    b.House.Address = "two's house"
    fmt.Printf("a's address: %s, b's address: %s\n", a.House.Address, b.House.Address)
}
```

      ❯ go run .\main.go
      a's address: one's house, b's address: two's house
采用这种方式进行深拷贝需要注意，由于会先序列化为字符串，因此会额外占用内存，当对象比较大时，需要格外留意内存占用情况，即使是thrift和protobuf这样的压缩比很高的库，也是存在风险的。另外在整个序列化和反序列化过程中，有可能由于频繁创建对象、申请内存，导致cpu占用也跟着升高！！！

- ## 使用reflect进行深拷贝
事实上，json和protobuf在序列化和反序列化时，使用了reflect库获取对象的字段和类型，那么我们也可以直接使用reflect来递归的读取对象的字段，并进行copy，这样就减少了序列化带来的内存占用，以及频繁字节数组扩容带来的cpu占用上升问题，并且可以完全去除反序列化的过程。不过这种方式的问题是，Go的reflect.Value对象不能复用，即使是相同类型的两个不同变量，也需要重新创建reflect.Value对象，这也造成reflect性能很差。
```golang
package main

import (
	"fmt"
	"reflect"
)

type House struct {
	Address string `json:"address"`
}

type Person struct {
	Name  string `json:"name"`
	House *House `json:"house"`
}

func shallowCopyValue(v reflect.Value) reflect.Value {
	switch v.Type().Kind() {
	case reflect.Ptr:
		return shallowCopyValue(v.Elem()).Addr()
	case reflect.Interface:
		return shallowCopyValue(v.Elem())
	case reflect.Array, reflect.Map, reflect.Func, reflect.Chan:
		return v
	default:
		return reflect.New(v.Type()).Elem()
	}
}

func deepcopyValue(v reflect.Value) reflect.Value {
	var value reflect.Value
	if v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface {
		value = v.Elem()
	} else {
		value = v
	}
	newIns := shallowCopyValue(v)
	newValue := newIns
	if v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface {
		newValue = newIns.Elem()
	}

	for i := 0; value.Kind() == reflect.Struct && i < value.Type().NumField(); i++ {
		field := value.Field(i)
		if !field.IsValid() {
			continue
		}
		newValue.Field(i).Set(deepcopyValue(field))
	}
	return newIns
}

func Deepcopy(ins interface{}) interface{} {
	if nil == ins {
		return nil
	}
	return deepcopyValue(reflect.ValueOf(ins)).Interface()
}

func main() {
	a := &Person{Name: "one", House: &House{Address: "one's house"}}
	b := Deepcopy(a).(*Person)
	b.House.Address = "two's house"
	fmt.Printf("a's address: %s, b's address: %s\n", a.House.Address, b.House.Address)
}
```

      ❯ go run main.go
      a's address: one's house, b's address: two's house

- ## 在编译期根据对象结构生成相应的复制代码
一般的，我们深拷贝一个简单对象，可以直接new一个新对象，然后对每个字段单独赋值来达到深拷贝的目的，这种方式相比前两种方式资源占用会更少，但是这种方式对于字段很多、层次很复杂的结构来说，要写的语句很多，而且实际开发中，任何结构都会不断变化，这种方式不能应对时刻变化的需求，如果能做到根据结构的定义，动态生成每个字段的复制代码，那不就是理想的深拷贝方法吗。幸运的是Go的标准库提供了对go文件词法解析的库```go/ast```，借助这个库我们可以在编译期递归解析代码里的结构体，生成每个字段的复制语句.
### go/ast包